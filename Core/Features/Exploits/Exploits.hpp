#pragma once
#include <Includes/Includes.hpp>
#include <Includes/Utils.hpp>
#include <Core/Offsets.hpp>
#include <Core/Core.hpp>
#include <iostream>
#include <fstream>
#include <string>
#include <regex>

namespace Core
{
	namespace Features
	{
		namespace Exploits
		{
			inline void NoClip()
			{
				// 1. Obtener el puntero del jugador local
				auto pLocal = Core::SDK::Pointers::pLocalPlayer;
				if (!pLocal) return;

				// 2. Determinar qué entidad vamos a mover (Vehículo o Jugador a pie)
				bool inVehicle = pLocal->InVehicle();
				
				// Usamos uintptr_t para manejar direcciones de memoria genéricas
				uintptr_t pTargetEntity = reinterpret_cast<uintptr_t>(pLocal);
				
				if (inVehicle) {
					auto pVeh = pLocal->GetLastVehicle();
					if (pVeh) {
						pTargetEntity = reinterpret_cast<uintptr_t>(pVeh);
					}
				}

				if (!pTargetEntity) return;

				// 3. Obtener Dirección de la Cámara para volar hacia donde miras
				uintptr_t CamDirector = Mem.Read<uintptr_t>(g_Offsets.m_CamGameplayDirector);
				if (!CamDirector) return;

				uintptr_t CurrentCam = Mem.Read<uintptr_t>(CamDirector + 0x2C0);
				if (!CurrentCam) return;

				D3DXVECTOR3 CamRot = Mem.Read<D3DXVECTOR3>(CurrentCam + 0x40);

				// 4. Configurar Velocidad
				float speed = g_Config.Player->NoClipSpeed;
				if (speed < 0.1f) speed = 1.0f; // Velocidad base por defecto
				
				// Turbo con Shift
				if (GetAsyncKeyState(VK_SHIFT) & 0x8000) speed *= 2.5f; 

				// 5. Calcular vectores de dirección (Matemática 3D para GTA V)
				float pitch = CamRot.x;
				float yaw = CamRot.z;

				float cp = cos(pitch);
				float sp = sin(pitch);
				float cy = cos(yaw);
				float sy = sin(yaw);

				// Vector Adelante (Hacia donde miras)
				D3DXVECTOR3 Forward;
				Forward.x = -sy * cp;
				Forward.y = cy * cp;
				Forward.z = sp;

				// Vector Derecha (Para moverse de lado con A/D)
				D3DXVECTOR3 Right;
				Right.x = cy;
				Right.y = sy;
				Right.z = 0.0f;

				// 6. Calcular nueva posición
				D3DXVECTOR3 CurrentPos = Mem.Read<D3DXVECTOR3>(pTargetEntity + 0x90);
				D3DXVECTOR3 NewPos = CurrentPos;
				bool isMoving = false;

				if (GetAsyncKeyState('W') & 0x8000) {
					NewPos.x += Forward.x * speed;
					NewPos.y += Forward.y * speed;
					NewPos.z += Forward.z * speed;
					isMoving = true;
				}
				if (GetAsyncKeyState('S') & 0x8000) {
					NewPos.x -= Forward.x * speed;
					NewPos.y -= Forward.y * speed;
					NewPos.z -= Forward.z * speed;
					isMoving = true;
				}
				if (GetAsyncKeyState('A') & 0x8000) {
					NewPos.x -= Right.x * speed;
					NewPos.y -= Right.y * speed;
					NewPos.z -= Right.z * speed;
					isMoving = true;
				}
				if (GetAsyncKeyState('D') & 0x8000) {
					NewPos.x += Right.x * speed;
					NewPos.y += Right.y * speed;
					NewPos.z += Right.z * speed;
					isMoving = true;
				}
				// Subir/Bajar con Espacio/Control
				if (GetAsyncKeyState(VK_SPACE) & 0x8000) {
					NewPos.z += speed * 0.5f;
					isMoving = true;
				}
				if (GetAsyncKeyState(VK_CONTROL) & 0x8000) {
					NewPos.z -= speed * 0.5f;
					isMoving = true;
				}

				// 7. Aplicar movimiento y ANULAR GRAVEDAD
				if (isMoving) {
					// Actualizar posición visual
					Mem.Write<D3DXVECTOR3>(pTargetEntity + 0x90, NewPos);

					// Actualizar posición en navegación (importante para evitar tp back)
					uintptr_t Navigation = Mem.Read<uintptr_t>(pTargetEntity + 0x30);
					if (Navigation) {
						Mem.Write<D3DXVECTOR3>(Navigation + 0x50, NewPos);
						Mem.Write<D3DXVECTOR3>(Navigation + 0x30, D3DXVECTOR3(0, 0, 0)); // Rotación nav
					}
				}

				// CRÍTICO: Escribir velocidad 0 constantemente en 0x320 para flotar
				// Esto reemplaza al "FreezePed" y funciona mejor en autos
				Mem.Write<D3DXVECTOR3>(pTargetEntity + 0x320, D3DXVECTOR3(0, 0, 0));
			}

			inline void TpToWaypoint() {
				Core::SDK::Pointers::pLocalPlayer->FreezePed(true);
				for (int i = 0; i < 2000; i++) {
					uintptr_t Blip = Mem.Read<uintptr_t>(g_Offsets.m_BlipList + (8U * i));
					if (!Blip) continue;
					int BlipIcon = Mem.Read<int>(Blip + 0x40);
					int BlipColor = Mem.Read<int>(Blip + 0x48);
					if (BlipIcon != 8) continue;
					D3DXVECTOR2 BlipPos = Mem.Read<D3DXVECTOR2>(Blip + 0x10);
					Core::SDK::Pointers::pLocalPlayer->SetPos(D3DXVECTOR3(BlipPos.x, BlipPos.y, -210.f));
					Core::SDK::Pointers::pLocalPlayer->FreezePed(false);
				}
			}
		}
	}
}
