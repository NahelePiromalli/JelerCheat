#include "FreeCam.h"
#include <WinUser.h>
#include <Core/Config.hpp>
#include <Core/SDK/Memory.hpp>
#include <Core/SDK/SDK.hpp>

void Features2::FreeCam::UpdateMode() {
	static bool bRight = false;
	static bool bLeft = false;

	bool bIsRight = GetAsyncKeyState(VK_RIGHT) & 0x8000;
	bool bIsLeft = GetAsyncKeyState(VK_LEFT) & 0x8000;

	if (bIsRight && !bRight) {
		Core::g_Config.Player->current_mode++;
		if (Core::g_Config.Player->current_mode >= Core::g_Config.Player->iMaxModes)
			Core::g_Config.Player->current_mode = 0;
	}

	if (bIsLeft && !bLeft) {
		Core::g_Config.Player->current_mode--;
		if (Core::g_Config.Player->current_mode < 0)
			Core::g_Config.Player->current_mode = Core::g_Config.Player->iMaxModes - 1;
	}

	bRight = bIsRight;
	bLeft = bIsLeft;
}

void Features2::FreeCam::RenderMode() {
	const char* ModeNames[] = { "Look Around", "Lock Vehicle [E]", "Unlock Vehicle [E]", "Explode Vehicle [E]","Teleport Vehicle To Sky [E]", "Teleport Vehicle To Void [E]" };
	std::string sDisplayText = xorstr("FreeCam Mode: ") + std::string(ModeNames[Core::g_Config.Player->current_mode]);
	std::string sInstructions = xorstr("Right/Left Arrow = Switch Mode");

	ImVec2 vTextSize = ImGui::CalcTextSize(sDisplayText.c_str());
	ImVec2 vInstructionSize = ImGui::CalcTextSize(sInstructions.c_str());

	float fWidth = vTextSize.x;
	if (vInstructionSize.x > vTextSize.x) {
		fWidth = vInstructionSize.x;
	}

	float fPadding = 15.0f;
	float fRounding = 10.0f;

	ImVec2 vPos = ImVec2(ImGui::GetIO().DisplaySize.x / 2 - fWidth / 2 - fPadding, ImGui::GetIO().DisplaySize.y - ImGui::GetTextLineHeightWithSpacing() * 3 - fPadding - 70.0f);
	ImVec2 vSize = ImVec2(fWidth + fPadding * 2, vTextSize.y + vInstructionSize.y + fPadding * 3);

	ImGui::SetNextWindowPos(vPos);
	ImGui::SetNextWindowBgAlpha(0.5f);

	if (ImGui::Begin(xorstr("FreeCam Mode"), nullptr, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav)) {
		ImVec2 vMin = vPos;
		ImVec2 vMax = ImVec2(vPos.x + vSize.x, vPos.y + vSize.y);

		ImGui::GetWindowDrawList()->AddRect(vMin, vMax, IM_COL32(0, 128, 244, 255), fRounding, ImDrawFlags_RoundCornersAll, 2.0f);

		ImGui::Text(xorstr("%s"), sDisplayText.c_str());
		ImGui::Text(xorstr("%s"), sInstructions.c_str());
	}
	ImGui::End();
}

void Features2::FreeCam::Loop() {
	while (true) {
		for (auto& Entity : Core::SDK::Game::EntityList)
		{
			CPed* Ped = Entity.Ped;

			bool IsLocalPlayer = Ped == Core::SDK::Pointers::pLocalPlayer;

			if (IsLocalPlayer)
				continue;

			static bool bWasFreecam = false;
			static bool bWasCustomFov = false;
			static bool bWasFreeze = false;
			static bool bWasVehicleFreeze = false;
			static bool bWasInvisibleWhile = false;

			{ //FreeCam
				if (Core::g_Config.Player->FreeCamActivate) {

					std::vector<uint8_t> Nop = { 0x90, 0x90, 0x90, 0x90, 0x90 };

					Core::Mem.WriteRaw(Core::Mem.ModBase + g_Offsets.m_CameraX, Nop.data(), Nop.size());
					Core::Mem.WriteRaw(Core::Mem.ModBase + g_Offsets.m_CameraY, Nop.data(), Nop.size());
					Core::Mem.WriteRaw(Core::Mem.ModBase + g_Offsets.m_CameraZ, Nop.data(), Nop.size());

					if (!bWasFreeze) {
						Core::SDK::Pointers::pLocalPlayer->FreezePed(true);
						bWasFreeze = true;
					}

					if (!bWasVehicleFreeze) {
						/*if (SDK::g_Cache->pLocalPed->btPedTask() & (1 << 6)) {
							SDK::g_Cache->pLocalPed->pModelInfo()->fClearTask(0.f);
							bWasVehicleFreeze = true;
						}*/
					}

					//if (Core::g_Config.Player->invisible_while_activate) {
					//	Core::SDK::Pointers::pLocalPlayer->bSetInvisible(true);
					//	bWasInvisibleWhile = true;
					//}
					//else if (!Core::g_Config.Player->invisible_while_activate && bWasInvisibleWhile) {
					//	Core::SDK::Pointers::pLocalPlayer->bSetInvisible(false);
					//	bWasInvisibleWhile = false;
					//}

					if (Core::g_Config.Player->teleport_to_disable) {
						Core::SDK::Pointers::pLocalPlayer->fClearTask(0.f);
					}

					vLocation = Core::SDK::Pointers::pLocalPlayer->vLocation();
					vRotation = Core::SDK::Pointers::pLocalPlayer->vRotation(Core::SDK::Pointers::pLocalPlayer->bIsFristPerson());

					float fSpeed = Core::g_Config.Player->FreeCamSpeed - 0.7f;

					if (GetAsyncKeyState(VK_SHIFT)) {
						if (Core::g_Config.Player->FreeCamSpeed < 5.0f) {
							fSpeed *= 2.5f;
						}
						else {
							fSpeed *= 1.5f;
						}
					}

					//if (Core::g_Config.Player->FreeCamCustomFov) {
					//	Core::SDK::Pointers::pLocalPlayer->fSetFov(Core::g_Config.Player->FreeCamFovAmount);
					//	bWasCustomFov = true;
					//}
					//else if (!Core::g_Config.Player->FreeCamCustomFov && bWasCustomFov) {
					//	Core::SDK::Pointers::pLocalPlayer->fSetFov(50);
					//	bWasCustomFov = false;
					//}

					if (GetAsyncKeyState(0x57) & 0x8000) { // W
						vLocation.x += (vRotation.x * fSpeed);
						vLocation.y += (vRotation.y * fSpeed);
						vLocation.z += (vRotation.z * fSpeed);
					}

					if (GetAsyncKeyState(0x53) & 0x8000) { // S
						vLocation.x -= (vRotation.x * fSpeed);
						vLocation.y -= (vRotation.y * fSpeed);
						vLocation.z -= (vRotation.z * fSpeed);
					}

					if (GetAsyncKeyState(0x41) & 0x8000) { // A
						vLocation.x -= (vRotation.y * fSpeed);
						vLocation.y += (vRotation.x * fSpeed);
						vLocation.z += (vRotation.z * fSpeed);
					}

					if (GetAsyncKeyState(0x44) & 0x8000) { // D
						vLocation.x += (vRotation.y * fSpeed);
						vLocation.y -= (vRotation.x * fSpeed);
						vLocation.z -= (vRotation.z * fSpeed);
					}

					if (GetAsyncKeyState(0x20) & 0x8000) { // Up
						vLocation.z += fSpeed;
					}

					if (GetAsyncKeyState(0x11) & 0x8000) { // Down
						vLocation.z -= fSpeed;
					}

					Core::SDK::Pointers::pLocalPlayer->vSetLocation(vLocation);

					bWasFreecam = true;
				}
				else {
					std::vector<uint8_t> NopX = { 0xF3, 0x0F, 0x11, 0x47, 0x60 };
					std::vector<uint8_t> NopY = { 0xF3, 0x0F, 0x11, 0x4F, 0x64 };
					std::vector<uint8_t> NopZ = { 0xF3, 0x0F, 0x11, 0x47, 0x68 };

					Core::Mem.WriteRaw(Core::Mem.ModBase + g_Offsets.m_CameraX, NopX.data(), NopX.size());
					Core::Mem.WriteRaw(Core::Mem.ModBase + g_Offsets.m_CameraY, NopY.data(), NopY.size());
					Core::Mem.WriteRaw(Core::Mem.ModBase + g_Offsets.m_CameraZ, NopZ.data(), NopZ.size());

					if (bWasFreecam) {
						if (bWasFreeze) {
							Core::SDK::Pointers::pLocalPlayer->FreezePed(false);
							bWasFreeze = false;
						}

						/*if (bWasCustomFov) {
							Core::SDK::Pointers::pLocalPlayer->fSetFov(50);
							bWasCustomFov = false;
						}

						if (bWasInvisibleWhile) {
							Core::SDK::Pointers::pLocalPlayer->bSetInvisible(false);
							bWasInvisibleWhile = false;
						}*/

						/*if (Core::g_Config.Player->teleport_to_disable) {
							if (SDK::g_Cache->pLocalPed->btPedTask() & (1 << 6)) {
								SDK::g_Cache->pLocalPed->pVehicle()->vSetLocation(vLocation);
								SDK::g_Cache->pLocalPed->pVehicle()->pNavigation()->vSetLocation(vLocation);
							}
							else {
								SDK::g_Cache->pLocalPed->vSetLocation(vLocation);
								SDK::g_Cache->pLocalPed->pNavigation()->vSetLocation(vLocation);
							}
						}*/

						//Core::SDK::Pointers::pLocalPlayer->fClearTask(1.f);

						/*if (bWasVehicleFreeze) {
							if (SDK::g_Cache->pLocalPed->btPedTask() & (1 << 6)) {
								SDK::g_Cache->pLocalPed->pVehicle()->pModelInfo()->fClearTask(1.f);
							}
						}*/
						bWasFreecam = false;
					}
				}
			}

			{ //FreeCam Options
				if (Core::g_Config.Player->FreeCamActivate) {

					/*for (auto Entity : Core::SDK::Game::VehicleList)
					{
						CVehicle* Vehicle = Entity.Pointer;
					}
					SDK::Game::VehicleStructure CVehicleList = SDK::g_Functions->ClosestVehicle(vLocation, 13);*/

					//switch (Core::g_Config.Player->current_mode) {
					//case 1: // Lock Vehicle
					//	if (GetAsyncKeyState(0x45) & 1) {
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, true, true);

					//		pClosestVehicle->mSetLockState(2);

					//		Sleep(5);
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, false, false);
					//	}
					//	break;
					//case 2: // Unlock Vehicle
					//	if (GetAsyncKeyState(0x45) & 1) {
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, true, true);

					//		pClosestVehicle->mSetLockState(1);

					//		Sleep(5);
					//		SDK::g_Network->RequestControlOfVehicle(Core::SDK::Pointers::pLocalPlayer, pClosestVehicle, false, false);
					//	}
					//	break;
					//case 3: // Explode Vehicle
					//	if (GetAsyncKeyState(0x45) & 1) {
					//		SDK::g_Network->RequestControlOfVehicle(Core::SDK::Pointers::pLocalPlayer, pClosestVehicle, true, true);

					//		pClosestVehicle->fSetBodyHealth(-1.f);
					//		pClosestVehicle->fSetTankHealth(-1.f);
					//		pClosestVehicle->fSetEngineHealth(-1.f);

					//		Sleep(10);
					//		pClosestVehicle->fSetTankHealth(-998.f);

					//		Sleep(5);
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, false, false);
					//	}
					//	break;
					//case 4: // Telelport Vehicle To Sky 
					//	if (GetAsyncKeyState(0x45) & 1) {
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, true, true);

					//		Vector3 vPos = pClosestVehicle->vLocation();
					//		vPos.z += 40;

					//		SDK::g_Functions->Teleport((uintptr_t)pClosestVehicle, (uintptr_t)pClosestVehicle->pNavigation(), (uintptr_t)pClosestVehicle->pModelInfo(), vPos, true);

					//		Sleep(5);
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, false, false);
					//	}
					//	break;
					//case 5: // Telelport Vehicle To Void
					//	if (GetAsyncKeyState(0x45) & 1) {
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, true, true);

					//		SDK::g_Functions->Teleport((uintptr_t)pClosestVehicle, (uintptr_t)pClosestVehicle->pNavigation(), (uintptr_t)pClosestVehicle->pModelInfo(), Vector3(15000, 15000, 0), true);

					//		Sleep(5);
					//		SDK::g_Network->RequestControlOfVehicle(SDK::g_Cache->pLocalPed, pClosestVehicle, false, false);
					//	}
					//	break;
					//}
				}
			}
		}
	}
}

void Features2::FreeCam::Update()
{
	while (true)
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(10));
		try {
			//if ( !g_MenuInfo.IsLogged && !g_Variables.g_bPassedByThisVerify )
				//continue;

			Features2::g_FreeCam->Loop();
		}
		catch (const std::exception& e) {
			std::string errorMessage = xorstr("Crash Detected. Code: 2\nException: ");
			errorMessage += e.what();
			MessageBox(NULL, errorMessage.c_str(), xorstr("Error"), MB_ICONERROR);
			break;
		}
		catch (...) {
			MessageBox(NULL, xorstr("Crash Detected. Code: 2\nUnknown exception caught."), xorstr("Error"), MB_ICONERROR);
			break;
		}

	}
}